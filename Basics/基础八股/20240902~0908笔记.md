## 20240902~0908笔记

[toc]

#### 体系化答题
- 讲概念
- 详细说、说原理、优点
- 应用场景、案例
- 注意事项、缺点、如何避免
- 总的说

#### instanceof 原理
- 讲概念
  instanceof 是一个运算符，可以用于判断一个对象是否是一个构造函数的实例
- 说原理
  它是通过判断构造函数的prototype，是否出现在该对象实例的原型链上实现的
- 详细说
  就是通过检查对象object的原型链，是否包含构造函数constructor的原型对象，如果包含，那么对象object就是构造函数constructor的一个实例，返回true。如果对象object原型链中不存在构造函数constructor的原型对象，那么对象object就不是constructor的实例，返回false
- 应用场景（手写）
  ```JavaScript
  function myInstanceof (obj, constructor) {
    if (typeof obj !== 'object') { return false }
    let proto = Object.getPrototypeOf(obj)
    while (proto) {
      if (proto === constructor.prototype) {
        return true
      }
      proto = Object.getPrototypeOf(proto)
    }
    return false
  }
  ```
- 案例
  ```JavaScript
  function Animal () {}
  function Cat () {}
  Cat.prototype = new Animal()
  // Cat.prototype.constructor = Cat
  var cat = new Cat()
  console.log(cat instanceof Cat) // true
  console.log(cat instanceof Animal) // true
  ```
- 拓展（注意、缺点）
  - instanceof 只适用于判断某个对象是否构造函数的实例，不适用于基本数据类型的判断（如Number、String、Boolean、Undefined、Null、Symbol类型）。如果用于判断的不是一个对象，则会返回false
  - instanceof 是基于对象的原型链去判断的，如果原型链过长，则检查效率会比较低
- 总的说
  instanceof运算符判断的是对象的原型链和构造函数的原型，如果对象的原型链上有构造函数的原型，那么对象就是构造函数的实例，如果对象的原型链上没有构造函数的原型，即使对象和构造函数有相同的属性和方法，对象也不是构造函数的实例


#### new 原理
- 讲概念
  new运算符，用于创建自定义对象类型的实例，或创建有构造函数的内置对象的实例
- 说原理
  new具体做了以下几个步骤：
  1. 创建一个空对象，该对象的原型为构造函数的原型
  2. 将构造函数的this绑定为该空对象
  3. 执行构造函数代码，并将方法和属性添加到该空对象中
  4. 若构造函数显示返回一个对象，则new运算符返回该对象；否则new返回原先创建的空对象
- 手写new
  ```JavaScript
  function myNew (constructor, ...args) {
    // 创建一个空对象，并将空对象的原型绑定为构造函数的原型（用构造函数实例化一个空对象）
    const obj = Object.create(constructor.prototype)
    // 将构造函数的this绑定为该空对象；执行构造函数，获取返回
    const result = constructor.apply(obj, args)
    // 若构造函数显示返回了一个对象，则返回该对象
    return (typeof result === 'object' && result !== null) ? result : obj
  }
  ```

#### js 作用域
- 讲概念
  在JavaScript中，作用域（Scope）指在程序中定义的变量的可见范围
- 举例子
  在JavaScript中，作用域分为 全局作用域 和 函数作用域。
  全局作用域，是指在代码中任何地方都可以访问的变量，在整个应用程序中，都是可见的；
  函数作用域，是指在函数内部定义的变量，只在函数内部可访问，函数外部无法访问。
  在ES6之后，JavaScript还新增了一个特殊的作用域，块级作用域，通过 let 和 const 关键字可以创建块级作用域。
  块级作用域，是指在代码块中定义的变量，只能在代码块中访问，代码块外无法访问，代码块通常指用花括号囊括的代码合集。
- 总的说
  在JavaScript中，变量的作用域是由它们在代码中申明的位置所决定的，当程序执行时，JavaScript引擎会根据变量声明的位置来确定变量的作用域。通常let和const声明的变量，在声明位置下方都可以访问，在声明位置上方无法访问（死区）

#### js 事件流
- 讲概念
  JavaScript 事件流（Event Flow）是浏览器处理事件的方式
- 详细说
  事件流分为三个阶段：捕获阶段、目标阶段、冒泡阶段，这三个阶段从外到内，再从内到外，按照从父节点到子节点、子节点自身、再从子节点到父节点这样的顺序依次发生。
  事件流的过程如下：
  1. 捕获阶段：事件从最外层节点（文档对象）开始，逐级向下传播，直到达到事件的目标节点。
  2. 目标阶段：事件到达目标节点，触发目标节点上的事件处理函数。
  3. 冒泡阶段：事件从目标节点开始，逐级向上传播，直到达到最外层节点（文档对象）
- 拓展答
  在事件流中，事件的传播可以被停止或取消。可以使用：
  event.preventDefault()，取消当前元素的默认行为，但不阻止事件传播；
  event.stopPropagation()，阻止事件传播，但当前元素事件不阻止；
  event.stopImmediatePropagation()，阻止事件传播，同时阻止当前元素其它同类事件监听器的触发；
  <!-- ele.addEventListener(event, func, true / false) 第三个参数可以设定在事件捕获阶段还是冒泡阶段监听和执行 -->
  <!-- 在执行到上述阻止语句之前，已执行的事件不受影响 -->
- 总的说
  事件流是描述事件在页面元素中传播的顺序，包括事件捕获阶段、目标阶段、事件冒泡阶段。在事件捕获阶段，事件从最外层元素向内传递，直到目标元素；在目标阶段中，事件在目标元素上触发；在事件冒泡阶段，事件从目标元素向外冒泡，直到最外层元素。

#### js 事件轮询机制

#### 解释一下原型链****

#### 谈谈你对作用域的理解

#### 闭包作用和原理及使用场景

#### js连续多个bind，最后this指向是什么

#### 0.1 + 0.2 为什么不等于 0.3

#### symbol 这个新增的基础数据类型有什么用

#### typeof null 为什么是 object
